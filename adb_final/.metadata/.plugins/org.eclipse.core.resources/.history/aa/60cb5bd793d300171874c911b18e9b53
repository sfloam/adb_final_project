import java.util.LinkedList;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.Iterator;

/**
 * <h1>Transaction Manager</h1> 
 * The TransactionManager assigns each operation provided by the user's text file. 
 * The TransactionManager reads the parsed operation and determines if it is a begin,
 * read, write, read only, dump, fail, etc. Depending on the operation, the 
 * TransactionManager executes an action (see below).
 * 
 * <ul>
 * 		<li>Properties</li>
 * 		<ul>
 * 			<li><strong>running:</strong> a linked list of Transaction objects to determine which transactions are currently running</li>
 * 			<li><strong>age:</strong> a global integer to keep track of the order in which transactions began (may not be needed)</li>
 * 			<li><strong>dm:</strong> the DataManager object that was passed by ExecuteTransactions</li>
 * 		</ul>
 * </ul>
 * 
 * 
 */
public class TransactionManager {

	private LinkedList<Transaction> running;
	private int age;
	private DataManager dm;

	public TransactionManager(DataManager dm) {
		// May not need all of these
		this.running = new LinkedList<Transaction>();
		this.age = 0;
		this.dm = dm;
	}

	/**
	 * 
	 * assignTransaction
	 * 
	 * @param ArrayList<String>
	 *            operation - a tick from the text file (i.e. begin(T1))
	 * 
	 *            Types of Operations
	 *            <ul>
	 *            <li>begin</li>
	 *            	<ul>
	 *            	<li>Parse begin, T1 (or other transaction number).</li>
	 *            	<li>Check the running LinkedList to see if the transaction already began. If so, produce an error.</li>
	 *            	<li>If it is a new transaction, create a new Transaction object with it's age.</li>
	 *           	<li>Update the age age count so the next Transaction will have an higher age (higher == younger).</li>
	 *           	<li>Add the transaction object to the end of the running LinkedList.</li>
	 *            	</ul>
	 *            <li>Write</li>
	 *            	<ul>
	 *            	<li>Parse W(T4, x4,35) so that we have [W, T4, x4, 35].</li>
	 *            	<li>Check the running LinkedList to find transaction.</li>
	 *            	<li>Add the operation we are performing to the transaction's operations ArrayList for logging</li>
	 *           	<li>Add the variable id to the Transaction's correspondingVars HashSet<Integer> to determine which Variables to unlock at the end (when commit or even abort).</li>
	 *           	<li>Execute write instructions</li>
	 *           		<ul>
	 *           		<li> parse varID, transID, and varValue</li>
	 * 					<li> If the variable is locked because of another Transaction, we need some action</li>
	 * 					<li> Otherwise, lock the Variable, assign previousTransactionID to the ID of the 
	 * 						Transaction performing the write, and that Variable's correspondingTrasactionID
	 * 						HashSet<Integer> to include this Transaction's ID</li>
	 *            		</ul>
	 *            	</ul>
	 *             <li>Read</li>
	 *            	<ul>
	 *            	<li>Parse R(T4, x4) so that we have [R, T4, x4].</li>
	 *            	<li>Check the running LinkedList to find transaction.</li>
	 *            	<li>Add the operation we are performing to the transaction's operations ArrayList for logging</li>
	 *           	<li>Add the variable id to the Transaction's correspondingVars  HashSet<Integer> to determine which Variables to unlock at the end (when commit or even abort).</li>
	 *           	<li>Execute read instructions</li>
	 *           		<ul>
	 *           		//TODO: WRITE THIS UP
	 *            		</ul>
	 *            	</ul>
	 *            </ul>
	 * 
	 * 
	 *  
	 */

	public void assignTransaction(ArrayList<String> operation) {
		if (operation.get(0).equalsIgnoreCase("begin")) {
			boolean isNewTransaction = true;

			// traverses lists to see if transaction exists
			for (Transaction t : running) {
				if (t.getTransName().equals(operation.get(1))) {
					System.out.println("Transaction Exists! Multiple begins for same transaction!");
					isNewTransaction = false;
					break;
				}
			}

			// checks if this is a new transaction and not an existing one
			if (isNewTransaction) {
				String transName = operation.get(1).replaceAll("T", "");
				Transaction tObj = new Transaction(Integer.parseInt(transName));
				tObj.setAge(this.age);
				this.age++;
				running.add(tObj);
			}
		}

		// TODO: NOT FINISHED LOCKING
		else if (operation.get(0).equalsIgnoreCase("W")) {
			String transName = operation.get(1);

			for (Transaction t : running) {

				if ((t.getTransName()).equals(transName)) {

					// log transaction operations in transaction may come in handy for recovery
					t.operations.add(operation);

					// add the variable id to the transaction's correspondingVars HashSet<Integers>
					// to determine which variables to unlock at the end (when commits)
					t.addToCorrespondingVars(Integer.parseInt(operation.get(2).replaceAll("x", "")));

					// perform write instructions
					executeWriteInstruction(operation);

					break;
				}
			}
		}

		// TODO: NOT FINISHED LOCKING
		else if (operation.get(0).equalsIgnoreCase("R")) {
			String transName = operation.get(1);

			for (Transaction t : running) {
				if ((t.getTransName()).equals(transName)) {
					t.operations.add(operation);
					
					// TODO: Execute Instruction Operation
					executeReadInstruction(operation);
					break;
				}
			}
		}

		// may need to address missing sites and null pointers later on
		else if (operation.get(0).equalsIgnoreCase("fail")) {
			int siteID = Integer.parseInt(operation.get(1));
			try {
				dm.getSites().get(siteID).fail();
			}
			catch(Exception e) {
				System.out.println("Site Does Not Exist! Something went wrong with Failure!");
			}
			
		}

		// not complete
		else if (operation.get(0).equalsIgnoreCase("end")) {
			// parsing transName
			String transName = operation.get(1).replaceAll("T", "");
			int transID = Integer.parseInt(transName);

			// temp var
			HashSet<Integer> transVars = null;

			// go through existing trans to find it and get its vars
			for (Transaction t : this.running) {
				if (t.getID() == transID) {
					transVars = t.getCorrespondingVars();
					break;
				}
			}

			// using transaction's hashset of vars to avoid having to go through all sites
			if (transVars != null) {
				Iterator<Integer> varIDs = transVars.iterator();

				// temp dataVar
				Variable dataVar;
				while (varIDs.hasNext()) {
					int varID = varIDs.next();
					dataVar = dm.getVars().get(varID);
					Iterator<Integer> siteIDs = dataVar.getSiteLocations().iterator();
					// if size is zero, then no sites are avail or we are out of bounds meaning no
					// sites are avail
					while (siteIDs.hasNext()) {
						int siteID = siteIDs.next();
						if (dm.getSites().get(siteID).getLT() != null) {
							int val = dm.getSites().get(siteID).getLT().get(varID).getValue();
							dm.getVars().get(varID).setValue(val);
						}
					}
				}
			}

		}

		// not complete
		else if (operation.get(0).equalsIgnoreCase("dump")) {

		}

		// not complete
		else {
			System.out.println("Something wasn't covered: " + operation);
		}
	}

	/**
	 * executeWriteInstruction
	 * <ul>
	 * <li> parse varID, transID, and varValue</li>
	 * <li> If the variable is locked because of another Transaction, we need some action</li>
	 * <li> Otherwise, lock the Variable, assign previousTransactionID to the ID of the 
	 * 		Transaction performing the write, and that Variable's correspondingTrasactionID
	 * 		HashSet<Integer> to include this Transaction's ID</li>
	 * 
	 * I imagine that having this correspondingTransactionID will allow us to keep track of which
	 * Transactions are associated with which variables. This may not be necessary though in the
	 * long run since all Transaction(s) have associated Variable IDs in their correspondingVariables.
	 * Confirm before removing.
	 *
	 * @param operation (i.e. [W, T4, x4, 35])
	 */
	public void executeWriteInstruction(ArrayList<String> operation) {
		// TODO: do we need read locks and write locks separated
		Integer varID = Integer.parseInt(operation.get(2).replaceAll("x", ""));
		Integer transID = Integer.parseInt(operation.get(1).replaceAll("T", ""));
		Integer varValue = Integer.parseInt(operation.get(3));

		if (isWriteInstructionNotAllowed(varID, transID)) {
			// TODO: something when write is not allowed

		} else {
			dm.getVars().get(varID).setLock();
			dm.getVars().get(varID).setPreviousTransactionID(transID);
			dm.getVars().get(varID).addTransaction(transID);
			dm.replicate(varID, varValue);
		}
		System.out.println(dm);
	}

	/**
	 * isWriteInstructionNotAllowed is used to determine if we can write a value to a variable. 
	 * The method simply returns true if the Variable is locked by another Transaction or false 
	 * if it is not.
	 * 
	 * @param varInt
	 * @param transInt
	 * @return Returns weather the Variable is locked by another transaction or not
	 */
	public boolean isWriteInstructionNotAllowed(Integer varInt, Integer transInt) {
		return ((dm.getVars().get(varInt).isLocked())
				&& (transInt != dm.getVars().get(varInt).getPreviousTransactionID()));
	}

	public void executeReadInstruction(ArrayList<String> operation) {
		//TODO: build this 
	}

}
