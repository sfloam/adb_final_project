import java.util.LinkedList;
import java.util.ArrayList;
import java.util.HashSet;

public class TransactionManager {

	private LinkedList<Transaction> running;
	private int age;
	private DataManager dm;

	// SITES IS starting from 1 NOT zero
	public TransactionManager(DataManager dm) {
		// May not need all of these
		this.running = new LinkedList<Transaction>();
		this.age = 0;
		this.dm = dm;
	}

	public void assignTransaction(ArrayList<String> transaction) {

		if (transaction.get(0).equalsIgnoreCase("begin")) {
			boolean isNewTransaction = true;

			// Traverses lists to see if transaction exists
			for (Transaction t : running) {
				if (t.getTransName().equals(transaction.get(1))) {
					System.out.println("Transaction Exists! Multiple begins for same transaction!");
					isNewTransaction = false;
					break;
				}
			}

			// Checks if this is a new transaction and not an existing one
			if (isNewTransaction) {
				String transName = transaction.get(1).replaceAll("T", "");
				Transaction tObj = new Transaction(Integer.parseInt(transName));
				tObj.setAge(this.age);
				this.age++;
				running.add(tObj);
			}
		}

		// not complete
		else if (transaction.get(0).equalsIgnoreCase("W")) {
			String transName = transaction.get(1);
			for (Transaction t : running) {
				if ((t.getTransName()).equals(transName)) {
					t.operations.add(transaction);
					t.addVar(Integer.parseInt(transaction.get(2).replaceAll("x", ""))); //we have correspondingVars to determine which to unlock at the end
					// TODO: Execute INstruction Operation
					executeWriteInstruction(transaction);
					break;
				}
			}
		}

		// not complete
		else if (transaction.get(0).equalsIgnoreCase("R")) {
			int index;
			String transName = transaction.get(1);
			boolean alreadyFound = false;

			for (Transaction t : running) {
				if ((t.getTransName()).equals(transName)) {
					t.operations.add(transaction);
					// TODO: Execute INstruction Operation
					executeReadInstruction(transaction);
					break;
				}
			}
		}

		// may need to address missing sites and null pointers later on
		else if (transaction.get(0).equalsIgnoreCase("fail")) {
			int siteID = Integer.parseInt(transaction.get(1));
			dm.getSites().get(siteID).fail();
		}

		// not complete
		else if (transaction.get(0).equalsIgnoreCase("end")) {
			//parsing transName
			String transName = transaction.get(1).replaceAll("T", "");
			int transID = Integer.parseInt(transName);
			
			//temp var
			HashSet<Integer> transVars = null;
			
			//go through existing trans to find it and get its vars
			for (Transaction t : this.running) {
				if (t.getID() == transID) {
					transVars = t.getCorrespondingVars();
					break;
				}
			}
			
			//using transaction's hashset of vars to avoid having to go through all sites
			if (transVars!=null) {
				for (int varID : transVars) {
					//setting vars value so we have most up to date vars values 
					if (dm.getVars().get(varID).getSiteLocations().size() > 0) {
						int i = 0;
						boolean 
						
					}
					else {
						//TODO: May need to take action
						System.out.println("NO SITE AVAILABLE!");
					}
					while ();
				}
			}

		}

		// not complete
		else if (transaction.get(0).equalsIgnoreCase("dump")) {

		}

		// not complete
		else {

			System.out.println("Something wasn't covered: " + transaction);
		}
	}

	public void executeWriteInstruction(ArrayList<String> operation) {
		Integer varInt = Integer.parseInt(operation.get(2).replaceAll("x", ""));
		Integer transInt = Integer.parseInt(operation.get(1).replaceAll("T", ""));
		Integer varValue = Integer.parseInt(operation.get(3));
		if (isWriteInstructionNotAllowed(varInt, transInt)) {
			//TODO: something when write is not allowed
		} // variable name, transactionID
		else {
			dm.getVars().get(varInt).setLock();
			dm.getVars().get(varInt).setPreviousTransactionID(transInt);
			dm.getVars().get(varInt).addTransaction(transInt);
			dm.replicate(varInt,varValue);
		}
		System.out.println(dm);
	}
	
	public boolean isWriteInstructionNotAllowed(Integer varInt, Integer transInt) {
		return ((dm.getVars().get(varInt).isLocked()) 
				&& (transInt != dm.getVars().get(varInt).getPreviousTransactionID())); 
	}

	public void updateLockTables(Integer varInt) {
	}

	public void executeReadInstruction(ArrayList<String> operation) {

	}

}
